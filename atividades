                        mov     #vetor,R5      ;inicializando o vetor 
			call	#ordena        ;chamando a subrotina ordena
			jmp	$	       ;travando o programa
			nop

ordena:                 mov.b	@R5,R4		;contador da varredura R4
			dec	R4		;o contador é decrementado, tendo em vista que a última posição da varredura já será fixada pelo maior numero	
			mov.b	@R5,R12		;contador de reiniciar a varredura R12
			dec	R12		;o contador é decrementado, pois a reinicialização do vetor só será contada depois da primeira varrida
			inc 	R5		;próximo endereço do vetor R5
lb1:			mov.b	@R5,R6		;movendo o endereço atual de R5 para R6
			inc	R5              ;próximo endereço do vetor R5
			mov.b	@R5,R7		;movendo endereço atual de R5 para R7
			cmp.b	R6,R7		;comparando as duas posições do vetor R5 que foram movidas para R6 e R7
			jhs	sim		;se R7 for maior que R6, pulamos para o label sim
			jlo	nao		;se R7 for menor que R6, pulamos para o label nao

sim:
			mov.b	R6,R10		;R10 guarda o menor numero (R6)
			mov.b	R7,R11		;R11 guarda o maior numero (R7)
			jmp	continua	;pula para o label continua
nao:
			mov.b	R6,R11		;R11 guarda o maior numero (R6)
			mov.b	R7,R10		;R10 guarda o menor numero (R7)

continua:	        mov.b	R10,-1(R5)	;movendo o menor valor para a posição anterior ao que o ponteiro se encontra
			mov.b	R11,0(R5)	;movendo o maior valor para a posição atual de R5
			dec	R4		;contador da varredura decrementado
			jnz	lb1		;repetindo a operação até que se varra todo o vetor
			mov	#vetor,R5	;voltando para a posição inicial de R5 (tamanho do vetor)
			inc	R5		;indo para o primeiro elemento do vetor
			dec	R12		;contador de reinicialização de varredura decrementado
			mov.b	R12,R4		;fazendo com que o contador de varredura seja igual ao contador de reinicialização de varredura
			jnz	lb1		;enquanto não terminar toda a varredura de reinicialização, continua-se o label lb1

			ret			;saindo da subrotina



			.data
vetor:		.byte	7,	"ANALUMA"
















;ATIVIDADE 1

			 MOV	#VETOR,R5
			 CALL	#MENOR
			 JMP	$

MENOR:			MOV.B	@R5,R8
			MOV.B	#255,R6
LB3:			INC	R5
			CMP.B	@R5,R6
			JEQ	LB1
			JHS	LB2
			DEC.B	R8
			JNZ	LB3
			RET
LB2:			MOV.B	@R5,R6
			CLR.B	R7
LB1:			INC.B	R7
			DEC.B	R8
			JNZ	LB3
			RET

				.data
VETOR:			.byte	7,"ANALUMA"


;ATIVIDADE 2

			 MOV	#VETOR,R5
             		CALL	#MAIOR
            		 JMP	$

MAIOR:			MOV	@R5,R8
 			CLR	R6
LB1:			INCD	R5
 			CMP	@R5,R6
 			JEQ	LB3
 			JLO	LB2
 			DEC	R8
 			JNZ	LB1
 			RET
LB2:			MOV	@R5,R6
			CLR	R7
LB3:			INC	R7
			DEC	R8
			JNZ	LB1
			RET


				.data
VETOR:			.byte	7,"ANALUMA"

;ATIVIDADE 3
-----------------
-----------------

			MOV	#VETOR,R5
			CALL	#M2M4
			JMP		$

M2M4:			MOV.B	@R5,R8
			CLR.B	R6
			CLR.B	R7
LB1:			INC	R5
			DEC.B	R8
			JZ	LB2
			MOV.B	@R5,R9
			RRC.B	R9
			JC	LB1
			INC.B	R6
			RRC.B	R9
			JC	LB1
			INC.B	R7
			JNZ	LB1
LB2:			MOV.B	@R5,R9
			RRC.B	R9
			JC	LB3
			INC.B	R6
			RRC.B	R9
			JC	LB3
			INC.B	R7
LB3:			RET

			.data
VETOR:		.byte	7,"ANALUMA"


;ATIVIDADE 4
		
			MOV		#VETOR,R5
			CALL		#EXTREMOS
			JMP		$

EXTREMOS:		MOV		#32767,R6
			MOV		#-32768,R7 ;como representar um numero negativo?
			MOV		@R5,R8
LB2:			INCD		R5
			DEC		R8
			JZ		LB3
			CMP		@R5,R6
			JL		LB1
			MOV		@R5,R6
			CMP		@R5,R7
			JGE		LB1
			MOV		@R5,R7
			JNZ		LB2
LB1:			CMP		@R5,R7
			JGE		LB2
			MOV		@R5,R7
			JNZ		LB2
LB3:			CMP		@R5,R6
			JL		LB4
			MOV		@R5,R6
LB4:			CMP		@R5,R7
			JGE		LB5
			MOV		@R5,R7
LB5:			RET


			.data
VETOR:		.word	8,140,129,341,-1997,150,251,879,-1997


		

;ATIVIDADE 5


               MOV	#VETOR1,R5
               MOV	#VETOR2,R6
               MOV	#VETORS,R7
               CALL	#SUM16
               JMP	$

SUM16:		MOV	@R5,R8
LB1:		INCD	R5
		INCD	R6
		INCD	R7
		MOV	@R6,0(R7)
		ADD	@R5,0(R7)
		DEC	R8
		JNZ	LB1
		RET

				.data
VETOR1:			.word	7,2021,2223,2425,2627,2829,3031,3233
VETOR2:			.word	7,6867,6665,6463,6261,6059,5857,5655
VETORS:			.word	7,0,0,0,0,0,0,0


;ATIVIDADE 6

              	MOV		#VETOR1,R5
              	MOV		#VETOR2,R6
              	MOV		#VETORS,R4
              	CALL		#SUM_TOT
              	JMP		$

SUM_TOT:	MOV		@R5,R9
		CLR		R7
		CLR		R8
LB1:		INCD		R5
		INCD		R6
		INCD		R4
		MOV		@R6,0(R4)
		ADD		@R5,0(R4)
		DEC		R9
		JNZ		LB1
		MOV		#VETORS,R4
		MOV		@R4,R11
LB3:		INCD		R4
		ADD		@R4,R7
		ADC		R8
		DEC		R11
		JNZ		LB3
		RET

				.data
VETOR1:			.word	7,2021,2223,2425,2627,2829,3031,3233
VETOR2:			.word	7,6867,6665,6463,6261,6059,5857,5655
VETORS:			.word	7,0,0,0,0,0,0,0

;ATIVIDADE 7

				CALL	#FIB
				JMP	$

FIB:				MOV	#0X2400,R5
				MOV	#40,0(R5)
				MOV	@R5,R8
				INCD	R5
				MOV	#0,0(R5)
				INCD	R5
				MOV	#1,0(R5)
				DECD	R8
				DECD	R8
LB1:				MOV	@R5,R7
				ADD	-1(R5),R7
				INCD	R5
				MOV	R7,0(R5)
				DECD	R8
				JNZ	LB1
				RET
				
				
				
;ATIVIDADE 8









-----------------
-----------------
			clr		  R6          ;zera meu contador
			mov		  #19,R6      ;meu contador recebe valor 19 para fazer 20 operações 
 			mov		  #1,R7       ;coloco 1 em R7
 			mov		  #2,R8       ;coloco 2 em R8
 			mov.w	  #vetor,R5   ;coloco um vetor de 16bits em R5
 			call	  #fibo       ;chamo minha subrotina
			NOP               ;paro o programa
			JMP		  $
			NOP

fibo:	mov.w	  R7,0(R5)    ;Coloco o valor de R7 no vetor R5
 			inc		  R5          ;passo para os proximos bits do vetor
 			inc		  R5
 			mov.w 	R8,0(R5)    ;coloco o valor de R8 no vetor R5 (agora ele vai ter uma posicao a frente pois incrementei antes)
 			mov		  R7,R9       ;começo agora a logica do fibonacci
 			add		  R8,R9
 			mov		  R8,R7
 			mov		  R9,R8
 			dec		  R6          ;decremento meu contador
 			jnz		  fibo        ;enquanto meu contador nao zerar, repito minha subrotina

 			ret                 ;retorno


    		     .data
vetor:		   .word	20    ;meu vetor possui 20, duvida: deveria ser 10? SIM



                                     
